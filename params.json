{"name":"Marathon-tips","tagline":"Dicas de maratonas de programação","body":"===================================\r\nDicas para Maratonas de Programação\r\n===================================\r\n\r\nSobre este documento\r\n====================\r\nEste documento foi iniciado por Denis Costa.\r\n\r\nEste documento foi utilizado `reStructuredText`_ e está sob licença\r\n`Creative Commons`_.\r\n\r\nData de última compilação:\r\n\r\nO que este documento é\r\n----------------------\r\n\r\n*   Guia introdutório para quem deseja comecar a participar de maratonas de\r\n    programação.\r\n\r\nO que este documento não é\r\n--------------------------\r\n\r\n*   Guia introdutório à programação.\r\n*   Guia referência para C, C++ ou Java.\r\n\r\nDicas Gerais\r\n============\r\n\r\n*   Sempre leia o problema todo e com atenção. Apesar de grande parte do texto\r\n    do problema não ajudar na resolução do problema em si, as vezes informações\r\n    importantes estão perdidas no meio do enunciado\r\n\r\n*   Use a linguagem que você e seu time mais domina. Conhecer a biblioteca\r\n    padrão da linguagem escolhida é imprescindível para se sair bem nas\r\n    maratonas de programação.\r\n\r\n*   Treine! Como a maioria das tarefas que os seres humanos desenvolvem,\r\n    programar exige treino. Treine sozinho e discuta sua solução com amigos\r\n    que também resolveram o mesmo problema para que ambos aprendam. Treinos\r\n    em equipe também são bem-vindos.\r\n\r\n*   Durante a maratona, divida os problemas entre todos os membros do time para\r\n    escolher os mais fáceis. O segundo critério para ver se um problema é fácil\r\n    é verificar o ranking e ver quais os problemas estão sendo mais respondidos\r\n    pelos outros times.\r\n\r\nTipos\r\n=====\r\n\r\nNas maratonas é muito importante saber os tipos que a linguagem suporta pois,\r\nse mal utilizados, pode acontecer de uma variável estourar o limite.\r\n\r\nC++\r\n---\r\n\r\nInteiros\r\n~~~~~~~~\r\n\r\nEm C++ os tipos numéricos inteiros mais importantes são **int**, **long**, e\r\n**long long**.\r\n\r\nEm C++, existe uma versão desses tipos sem o sinal de positivo e negativo. E\r\nnesse caso o número é sempre positivo. Se o problema que você estiver\r\nresolvendo não envolver números negativos e precisar armazenar números'grandes,\r\nisso pode ser útil. Para usar o números sem sinal, use a palavra-chave\r\n``ùnsigned``.\r\n\r\n.. Código não testado\r\n\r\n.. code:: c++\r\n\r\n    #include <iostream>\r\n\r\n    int main(){\r\n        /*\r\n        Declaração de inteiros\r\n        */\r\n\r\n        int i;                  // int com sinal\r\n        unsigned int ui;        // int sem sinal\r\n        long l;                 // long com sinal\r\n        unsigned long ul;       // long sem sinal\r\n        long long ll;           // long long com sinal\r\n        unsigned long long ull; // long long sem sinal\r\n\r\n        return 0;\r\n    }\r\n\r\nSegue uma tabela com a capacidade dos tipos em C++:\r\n\r\n+-----------+----------+----------------------------------------------------------+----------------------------------+\r\n| **tipo**  | **bits** | **range com sinal**                                      | **range sem sinal**              |\r\n+-----------+----------+----------------------------------------------------------+----------------------------------+\r\n| int       | 16       | -32768 até 32767                                         | 0 até 65535                      |\r\n+-----------+----------+----------------------------------------------------------+----------------------------------+\r\n| long      | 32       | -2,147,483,648 até 2,147,483,647                         | 0 até 4,294,967,295              |\r\n+-----------+----------+----------------------------------------------------------+----------------------------------+\r\n| long long | 64       | -9,223,372,036,854,775,808 até 9,223,372,036,854,775,807 | 0 até 18,446,744,073,309,551,615 |\r\n+-----------+----------+----------------------------------------------------------+----------------------------------+\r\n\r\n    **Dica**: É comum em problemas de maratona o uso da notação de um potencia\r\n    de base 2. Exemplo: \"1 <= N <= 2^32 - 1\". Fique atento para esses limites.\r\n    Nesse caso o melhor tipo é **unsigned long**.\r\n\r\nPonto flutuante\r\n~~~~~~~~~~~~~~~\r\n\r\nAinda existem 3 tipos de ponto flutuante: **float**, **double** e **long\r\ndouble**.\r\n\r\nO float tem 6 casas decimais de precisão, caso seja necessário uma precisão\r\nmaior use double.\r\n\r\n    **Dica**: A baixa precisão do **float** pode causar resultados divergentes.\r\n    Isso é bem comum quando o problema faz vários cálculos e arredondamentos\r\n    com o número **float**. Nesses casos prefira **double**.\r\n\r\n.. Código não testado\r\n\r\n.. code:: c++\r\n\r\n    #include <iostream>\r\n\r\n    int main(){\r\n        /*\r\n        Declaração de ponto flutuante\r\n        */\r\n\r\n        float f;\r\n        double d;\r\n        long double ld;\r\n\r\n        return 0;\r\n    }\r\n\r\nString e Char\r\n~~~~~~~~~~~~~\r\n\r\nOutros tipos básicos muito utilizados em maratonas são **char** e **string**.\r\n\r\nChar é um tipo primitivo de C++, que já existia em C. E possui 8 bits.\r\n\r\nUma string é um objeto de C++ que não existia em C. Este objeto possui alguns\r\nmétodos que facilitam a vida dos competidores em relação a quem usa C.\r\n\r\nBool\r\n~~~~\r\n\r\nEm C++, diferentes de C, existe o tipo booleano.\r\n\r\nMesmo assim as convenções de avaliação para verdadeio e falso de C ainda\r\npersistem.\r\n\r\nArrays e matrizes\r\n~~~~~~~~~~~~~~~~~\r\n\r\nJava\r\n----\r\n\r\nEntrada e Saída\r\n===============\r\n\r\nEntrada\r\n-------\r\n\r\nC++\r\n~~~\r\n\r\nEm C++ é possivel fazer a leitura da entrada padrão de várias formas. Para\r\nfazer a leitura de uma quantidade conhecida de elementos a melhor forma\r\ntalevez seja com **cin**. Para usar o **cin** é preciso incluir a biblioteca\r\n**iostream**.\r\n\r\n.. Código não testado\r\n\r\n.. code:: c++\r\n\r\n    #include <iostream>\r\n\r\n    using namespace std;\r\n\r\n    int main(){\r\n        int n;\r\n        string s;\r\n\r\n        cin >> n;\r\n        cin >> s;\r\n\r\n        return 0;\r\n    }\r\n\r\nEm algumas ocasiões o competidor pode preferir usar o **scanf** para\r\nler dados da entrada padrão. O **scanf** é uma herança da linguagem C\r\ne para usá-lo é preciso incluir a biblioteca **cstdio**. O **scanf**\r\nrecebe como primeiro parâmetro uma string com o formato de entrada. Dentro\r\ndessa string tem um \"marcador\" que inicia com o caractere ``%`` que indica o\r\ntipo do dado que vai ser lido. O segundo parâmetro é um ponteiro que aponta\r\npara a vaiável onde vai ser armazenado o valor.\r\n\r\n.. Código não testado\r\n\r\n.. code:: c++\r\n\r\n    #include <cstdio>\r\n\r\n    int main(){\r\n        int n;\r\n\r\n        scanf(\"%d\", &n);\r\n\r\n        return 0;\r\n    }\r\n\r\nO **cin**, apesar da sintaxe um pouco estranha inicialmente, é menos\r\nburocrático que o **scanf**, por isso prefira **cin**.\r\n\r\nO **cin** e o **scanf** le valores separados por espaço. Se for necessário ler\r\na linhas inteira e armazená-la em uma string é preciso usar o **getline**, que\r\ntambém está na biblioteca **iostream**.\r\n\r\n.. Código não testado\r\n\r\n.. code:: c++\r\n\r\n    #include <iostream>\r\n\r\n    using namespace std;\r\n\r\n    int main(){\r\n        string s;\r\n\r\n        getline(cin, s);\r\n\r\n        return 0;\r\n    }\r\n\r\nHá proglemas que precisam que você varra caractere por caractere. Para esse\r\ntipo de tarefa o **getchar** pode ser útil. O **getchar** está na biblioteca\r\n**cstdio**.\r\n\r\n.. Código não testado\r\n\r\n.. code:: c++\r\n\r\n    #include <cstdio>\r\n\r\n    int main(){\r\n        char c;\r\n\r\n        c = getchar();\r\n\r\n        return 0;\r\n    }\r\n\r\nJava\r\n~~~~\r\n\r\nNo Java a classe que faz a leitura dos dados da entrada padrão é a **Scanner**.\r\nEssa classe possui vário métodos para ler inteiros, floats, string, etc..\r\n\r\n.. Código não testado\r\n\r\n.. code:: java\r\n\r\n    import java.util.Scanner;\r\n\r\n    public class example {\r\n        public static void main(String[] args) {\r\n            Scanner s = new Scanner(System.in);\r\n\r\n            int n = s.nextInt();\r\n        }\r\n    }\r\n\r\nA classe **Scanner** possui muitos métodos para ler dados da entrada padrão.\r\nOs mais importante no contexto da maratona são:\r\n\r\n+------------+---------------------+\r\n| **Método** | **Tipo de retorno** |\r\n+------------+---------------------+\r\n| next       | String              |\r\n+------------+---------------------+\r\n| nextLine   | String              |\r\n+------------+---------------------+\r\n| nextInt    | int                 |\r\n+------------+---------------------+\r\n| nextLong   | long                |\r\n+------------+---------------------+\r\n| nextFloat  | float               |\r\n+------------+---------------------+\r\n| nextDouble | double              |\r\n+------------+---------------------+\r\n\r\nSaída\r\n-----\r\n\r\nC++\r\n~~~\r\n\r\nJava\r\n~~~~\r\n\r\nBiblioteca padrão\r\n=================\r\n\r\nCompilação e execução dos programas\r\n===================================\r\n\r\nApesar das IDEs (Integrated Development Environment), como Eclipse, para Java,\r\ne Code Blocks, para C/C++, podem ajudar muitos os programadores no dia-a-dia.\r\nMas nesse capítulo a compilação dos código será explicada a partir de um\r\nconsole, cmd no Windows e Bash no Linux. As maratonas ocorrem em lugares que\r\no ambiente de desenvolvimento é desconhecido para você. A única coisa que\r\nsempre haverá é um console.\r\n\r\nC++\r\n---\r\n\r\nOs software de apoio às maratonas compilam os programas C++ da seguinte forma:\r\n\r\n.. Código não testado\r\n\r\n::\r\n\r\n    g++ -lm programa.cpp\r\n\r\nA opção ``-lm`` adiciona a biblioteca **math**, de matemática. Em maratonas,\r\na única opção que modifica o comportamento padrão do compilador é a ``-lm``.\r\nNessas competições só é permitidos o uso da biblioteca padão e a biblioteca de\r\nmatemática. Use essa linha para compilar seus códigos e muito provavelmente\r\nvocê não terá problemas de compilação no servidor da maratona.\r\n\r\nA compilação dessa forma gera um arquivo chamado ``a.exe``, no Windows, ou\r\n``a.out``, no Linux. Se você quiser dar um nome para o arquivo executável\r\ncriado pelo compilador, digite:\r\n\r\n.. Código não testado\r\n\r\n::\r\n\r\n    g++ -lm -o programa programa.cpp\r\n\r\nA opção -o vem antes do nome do arquivo executavel.\r\n\r\nPara executar o programa que acabou de ser compilado, se você estiver no\r\nLinux, digite:\r\n\r\n.. Código não testado\r\n\r\n::\r\n\r\n    ./programa < in.txt\r\n\r\nE no Windows:\r\n\r\n.. Código não testado\r\n\r\n::\r\n\r\n    programa < in.txt\r\n\r\nEssa linha executa o programa e redireciona o conteúdo do arquivo de texto\r\n`in.txt` para a entrada padrão do programa. A entrada padrão, por default,\r\nrecebe dados que são digitados através do teclado. Ou seja, você tem a opção\r\nde executar o programa o não redirecionar o conteúdo de nenhum arquivo e\r\ndigitar todo o conteúdo. Apesar dessa opção ser válida, eu aconselho fortemente\r\nque você sempre coloque a entrada em um arquivo. Pois assim, só precisará\r\ndigitar uma vez a entrada.\r\n\r\n    **Dica**: Como os programa em maratonas tem nomes, use o padrão de colocar\r\n    o mesmo nome do problema no arquivo de entrada. Exemplo: `arroz.cpp` e\r\n    `arroz.txt`.\r\n\r\nEm Java\r\n-------\r\n\r\nA compilação e execução em Java são iguais para Windows e Linux. Para compilar\r\nos programas em Java digite:\r\n\r\n.. Código não testado\r\n\r\n::\r\n\r\n    javac programa.java\r\n\r\nIsso vai criar um arquivo `programa.class`. Para executar digite:\r\n\r\n.. Código não testado\r\n\r\n::\r\n\r\n    java programa < in.txt\r\n\r\nTreinamento\r\n===========\r\n\r\nAlguns site disponibilizam problemas no formato da maratona e permitem que\r\nvocê treine livremente. Uma caracteristica muito boa desses site é que grande\r\nparte do acervo de problemas desses site são de maratonas antigas. Isso te dá\r\numa prévia confiável de como é a maratona. Veja uma lista de alguns desses\r\nsites:\r\n\r\n*   `SPOJ Brasil`_\r\n*   `URI Online Judge`_\r\n\r\nAlgoritmos e funções mais comuns\r\n================================\r\n\r\nNúmeros Primos\r\n--------------\r\n\r\nÉ comum problemas de maratona envolvendo números primos. Alguns algoritmos\r\ncomo `Crivo de Eratóstenes`_ e o `Crivo de Atkins`_, são algoritmos\r\nextremamente eficientes. Mas na grande maioria dos casos o código, em C++ a\r\nbaixo responde muito rápido.\r\n\r\n.. Código não testado\r\n\r\n.. code:: c++\r\n\r\n    bool is_prime(int n){\r\n        if (n == 2) return true;\r\n        if (n < 2 || n % 2 == 0) return false;\r\n        for (int i = 3; i <= sqrt(n); i += 2){\r\n            if (n % i == 0) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\nReferências para as linguagens\r\n==============================\r\n\r\nC++\r\n---\r\n\r\n`CPlusPlus.com`_\r\n\r\nJava\r\n----\r\n\r\n`Java API especification`_\r\n\r\n.. _CPlusPlus.com: http://www.cplusplus.com/reference/\r\n.. _Creative Commons: http://creativecommons.org/licenses/by/4.0/\r\n.. _Crivo de Atkins: https://en.wikipedia.org/wiki/Sieve_of_Atkin\r\n.. _Crivo de Eratóstenes: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\r\n.. _Java API especification: http://docs.oracle.com/javase/7/docs/api/index.html\r\n.. _reStructuredText: http://docutils.sourceforge.net/rst.html\r\n.. _SPOJ Brasil: http://br.spoj.com/\r\n.. _URI Online Judge: www.urionlinejudge.com.br/\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}